#' Generate a representive sample of the posterior distribution
#'
#' The input graph object should be of class \code{causact_graph} and created using \code{dag_create()}.  The specification of a completely consistent joint distribution is left to the user.  Helpful error messages are scheduled for future versions of the \code{causact} package.
#'
#' @param graph a graph object of class \code{causact_graph} representing a complete and conistent specification of a joint distribution.
#' @param HMC a logical value indicating whether to sample using HMC sampler.  When \code{HMC=FALSE}, the Julia code is printed to the console, but not executed.  The user can cut and paste the code to another script for running line-by-line.  This option is most useful for debugging purposes. When \code{HMC=TRUE}, the code is executed in the global environment.
#' @param NUTS a logical value indicating whether to sample using NUTS sampler.  When \code{HMC=FALSE}, the Julia code is printed to the console, but not executed.  The user can cut and paste the code to another script for running line-by-line.  This option is most useful for debugging purposes. When \code{HMC=TRUE}, the code is executed in the global environment.
#' @param meaningfulLabels a logical value indicating whether to replace the indexed variable names in \code{draws} with abbreviated names representing the factor value corresponding to the index.  This argument is treated as \code{TRUE} regardless of user input.  The ability to retain numerical indexing will be in a subsequent release.
#' @param iterations an integer values indicating how many samples to return. The default is 4000 samples
#' @param eps the leapfrog step size for HMC sampler. The default is 0.1
#' @param tau the number of leapfrog step for HMC sampler. The default is 10 steps
#' @param rate the target accept ratio for NUTS sampler. The default is 0.65
#' @return If \code{HMC=TRUE} or \code{NUTS=TRUE}, running \code{dag_julia} populates the global envirnment with all inputs required to run statistical inference using \code{julia} and more importantly, creates three objects in the global environment that represent the posterior distribution and other information generated by HMCMC.  The three objects are:
#' \enumerate{
#' \item \code{draws}:  An Julia object containing raw output from the HMCMC/NUTS sampler used by \code{Julia}.
#' \item \code{draws_df}:  A wide data frame with all latent variables as columns and all draws as rows.  This data frame is useful for calculations based on the posterior
#' }
#'
#' @examples
#' graph = dag_create() %>%
#'   dag_node("Get Card","y",
#'            rhs = bernoulli(theta),
#'            data = carModelDF$getCard) %>%
#'   dag_node(descr = "Card Probability by Car",label = "theta",
#'            rhs = beta(2,2),
#'            child = "y") %>%
#'   dag_node("Car Model","x",
#'            data = carModelDF$carModel,
#'            child = "y") %>%
#'   dag_plate("Car Model","x",
#'             data = carModelDF$carModel,
#'             nodeLabels = "theta")
#'
#' graph %>% dag_render()
#' graph %>% dag_julia()
#' graph %>% dag_render(shortLabel = TRUE)
#' graph %>% dag_julia(NUTS=TRUE)
#' tidyDrawsDF %>% dagp_plot()
#' @importFrom dplyr bind_rows tibble left_join select add_row as_tibble
#' @importFrom DiagrammeR create_graph add_global_graph_attrs
#' @importFrom rlang enquo expr_text
#' @importFrom igraph graph_from_data_frame topo_sort
#' @importFrom tidyr gather
#' @importFrom greta mcmc model as_data
#' @export
dag_julia<- function(graph,
                     DynamicNUTS = FALSE,
                      NUTS = FALSE,
                      HMC = FALSE,
                      meaningfulLabels = TRUE,
                      iterations = 1000L,
                      eps = 0.1,
                      tau = 10L,
                      rate = 0.65,
                      ...) {
  
  ###get dimension information
  graph = graph %>% dag_dim()
  
  ###update rhs information for labelling computer code
  graph = juliaRhsPriorComposition(graph)
  graph = juliaRhsOperationComposition(graph)
  
  ###retrieve nodeDF,edgeDF,argDF,plateIndexDF, and plateNodeDF
  nodeDF = graph$nodes_df
  edgeDF = graph$edges_df
  argDF = graph$arg_df
  plateDF = graph$plate_index_df
  plateNodeDF = graph$plate_node_df
  dimDF = graph$dim_df
  
  ###arrangeNodes in topological order -> top-down
  nodeIDOrder = igraph::graph_from_data_frame(edgeDF %>% dplyr::select(from,to)) %>%
    igraph::topo_sort(mode = "out") %>%
    names() %>%
    as.integer()
  
  ## append non-connected nodes into nodeIDOrder
  nodeIDOrder = union(nodeIDOrder,nodeDF$id)
  
  ## arrange nodeDF by nodeIDOrder
  nodeDF = nodeDF[match(nodeIDOrder,nodeDF$id) , ] %>%
    dplyr::mutate(nodeOrder = row_number())
  
  ###Use DAPROPLIMOPO(DAta,PRior,OPeration,LIkelihood,MOdel,POsterior)
  ###Find all nodes that require data based on user input
  ###Err on the side of including a node
  
  ### Initialize all the code statements so that NULL
  ### values are skipped without Error
  dataStatements = NULL
  plateDataStatements = NULL
  dimStatements = NULL
  priorStatements = NULL
  opStatements = NULL
  likeStatements = NULL
  # use priorOpLikeDF to use topological order
  # for prior, operation, and likelihood statements
  priorOpLikeDF = data.frame(statement = as.character(NA),
                             orderID = as.integer(NA),
                             stringsAsFactors = FALSE)[-1,]
  priorOpLikeStatements = NULL
  modelStatement = NULL
  posteriorStatement = NULL
  
  
  ###DATA:  Create Code for Data Lines
  lhsNodesDF = nodeDF %>%
    dplyr::filter(obs == TRUE | !is.na(data)) %>%
    dplyr::filter(!(label %in% plateDF$indexLabel)) %>%
    dplyr::mutate(codeLine = paste0(auto_label,
                                    " <- ",
                                    data)) %>%
    dplyr::mutate(codeLine = paste0(abbrevLabelPad(codeLine), "   #DATA"))
  
  ###Aggregate Code Statements for DATA
  if(nrow(lhsNodesDF) > 0) {
    dataStatements = paste(lhsNodesDF$codeLine,
                           sep = "\n")
  }
  
  ###DIM:  Create code for plate dimensions
  plateDimDF = plateDF %>% dplyr::filter(!is.na(dataNode))
  
  if (nrow(plateDimDF) > 0) {
    plateDataStatements = paste(paste0(
      abbrevLabelPad(paste0(plateDimDF$indexLabel,
                            "    ")),# four spaces to have invis _dim
      " <- ",
      "as.integer(as.factor(",
      plateDimDF$dataNode,
      "))   #INDEX"
    ),
    sep = "\n")
    ###make labels for dim variables = to label_dim
    dimStatements = paste(
      paste0(abbrevLabelPad(paste0(plateDimDF$indexLabel,
                                   "_dim")),
             " = ",
             "length(unique(",
             plateDimDF$indexLabel,
             "))   #DIM"
      ),
      sep = "\n"
    )
  }
  
  ### Create MODEL Statement
  # get all non-observed / non-formula nodes by default,
  # treat index label as data 
  lhsNodesDF = nodeDF %>%
    dplyr::filter(obs == TRUE | !is.na(data)) %>%
    dplyr::pull(auto_label)

  
  modelStatement = paste0("julia_command(\"@model julia_model(",
                          paste0(lhsNodesDF, collapse = ","), 
                          ") = begin    #MODEL")
  
  ### Prior, Operations, and Likelihood Get Sorted by Topological Order
  
  ###PRIOR:  Create code for prior lines
  ###create dataframe of dataNodes and their data
  
  
  #update auto_rhs to use cbind for R indexing if there is a comma in it
  
  ######## NEW lhsNodesDF
  lhsNodesDF = nodeDF %>%
    dplyr::filter(distr == TRUE & obs == FALSE) %>%
    dplyr::rowwise() %>%
    dplyr::mutate(needPaded = ifelse(nrow(plateDimDF) > 0 & id %in% plateNodeDF$nodeID, 1, 0)) %>%
    dplyr::rowwise() %>%
    dplyr::mutate(codeLine = ifelse(needPaded > 0,
                                    paste0(abbrevLabelPad(auto_label)," = Array{Float64}(undef,", plateDimDF$indexLabel[plateNodeDF$indexID[which(plateNodeDF$nodeID == id)]], "_dim)\n", abbrevLabelPad(auto_label)," ~ ", "[" , auto_rhs, "]\n"),
                                    paste0(abbrevLabelPad(auto_label)," = Array{Float64}(undef,1)\n",abbrevLabelPad(auto_label)," ~ ", auto_rhs))) %>% 
    as.data.frame() %>%
    dplyr::mutate(codeLine = paste0(abbrevLabelPad(codeLine), " #PRIOR"))
  
  
  ###Aggregate Code Statements for PRIOR
  priorStatements = paste(lhsNodesDF$codeLine,
                          sep = "\n")
  priorOpLikeDF = dplyr::bind_rows(priorOpLikeDF,
                                   data.frame(statement = priorStatements,
                                              orderID = lhsNodesDF$nodeOrder,
                                              stringsAsFactors = FALSE))
  
  ###OPERATION:  Create code for OPERATION lines
  lhsNodesDF = nodeDF %>%
    dplyr::filter(!is.na(rhs) & distr == FALSE) %>%
    dplyr::mutate(codeLine = paste0(abbrevLabelPad(auto_label),
                                    " = ",
                                    auto_rhs)) %>%
    dplyr::mutate(codeLine = paste0(abbrevLabelPad(codeLine), "   #OPERATION"))
  
  ###Aggregate Code Statements for OPERATION
  opStatements = paste(lhsNodesDF$codeLine,
                       sep = "\n")
  priorOpLikeDF = dplyr::bind_rows(priorOpLikeDF,
                                   data.frame(statement = opStatements,
                                              orderID = lhsNodesDF$nodeOrder,
                                              stringsAsFactors = FALSE))
  
  ###LIKELIHOOD:  Create code for LIKELIHOOD lines
  lhsNodesDF = nodeDF %>%
    dplyr::filter(obs == TRUE) %>%  ##only observed nodes
    dplyr::inner_join(edgeDF, by = c("id" = "to")) %>% # only nodes with parents
    dplyr::distinct(id,auto_label,auto_rhs,nodeOrder) %>%
    dplyr::mutate(codeLine = paste0("for i in 1:length(", abbrevLabelPad(auto_label), ") \n " , auto_label, "[i] ~", auto_rhs, "\n end \n")) %>%
    dplyr::mutate(codeLine = paste0(abbrevLabelPad(codeLine), "   #LIKELIHOOD"))
  
  ###Aggregate Code Statements for LIKELIHOOD
  likeStatements = paste(lhsNodesDF$codeLine,
                         sep = "\n")
  priorOpLikeDF = dplyr::bind_rows(priorOpLikeDF,
                                   data.frame(statement = likeStatements,
                                              orderID = lhsNodesDF$nodeOrder,
                                              stringsAsFactors = FALSE))
  
  ### Use topological ordering
  if(nrow(priorOpLikeDF) > 0){
    priorOpLikeStatements = priorOpLikeDF %>%
      dplyr::arrange(orderID) %>%
      dplyr::pull(statement)
  }
  
  ## End Statement
  endStatement = paste0("end;\"", ")" )

  ### CALL MODEL AND ENGINE AND SAMPLING
  
  lhsNodesDF = nodeDF %>%
    dplyr::filter(obs == TRUE | !is.na(data)) %>%
    dplyr::pull(auto_label)
  
  callModelStatement = paste0("model  =  julia_call(\"julia_model\", ",
                          paste0(lhsNodesDF, collapse = ","),
                          ")   #CALL MODEL")
  
  DynamicNUTScallSamplerStatement = paste0("#Choose one of these 3 following engine:\n","engine  =  julia_call(\"DynamicNUTS\", ", iterations, "L)   #CALL DynamicNUTS SAMPLER")
  
  NUTScallSamplerStatement = paste0("engine  =  julia_call(\"Turing.NUTS\", ", iterations, "L,", rate,
           ")   #CALL NUTS SAMPLER")
  
  HMCcallSamplerStatement = paste0("engine  =  julia_call(\"HMC\", ", iterations, "L,", eps,",", tau, "L)   #CALL HMC SAMPLER")
  
  samplingStatement = paste0("draws  =  julia_call(\"sample\", ","model, ","engine",
                                ")", "\ndraws_df  =  julia_call(\"DataFrame\", ","draws",
                             ")    #SAMPLING")
  
  
  ##########################################
  ###Aggregate all code
  codeStatements = c(dataStatements,
                     plateDataStatements,
                     modelStatement,
                     dimStatements,
                     priorOpLikeStatements,
                     endStatement,
                     callModelStatement,
                     DynamicNUTScallSamplerStatement,
                     NUTScallSamplerStatement,
                     HMCcallSamplerStatement,
                     samplingStatement)
  
  DynamicNUTScodeStatements = c(dataStatements,
                         plateDataStatements,
                         modelStatement,
                         dimStatements,
                         priorOpLikeStatements,
                         endStatement,
                         callModelStatement,
                         DynamicNUTScallSamplerStatement,
                         samplingStatement)
  
  NUTScodeStatements = c(dataStatements,
                         plateDataStatements,
                         modelStatement,
                         dimStatements,
                         priorOpLikeStatements,
                         endStatement,
                         callModelStatement,
                         NUTScallSamplerStatement,
                         samplingStatement)
  
  HMCcodeStatements = c(dataStatements,
                         plateDataStatements,
                         modelStatement,
                         dimStatements,
                         priorOpLikeStatements,
                         endStatement,
                         callModelStatement,
                         HMCcallSamplerStatement,
                         samplingStatement)
  
  #codeStatements
  
  ###gretaCode as text
  paste0("## The specified DAG corresponds to the following Julia code: \n",
         paste(codeStatements, collapse = '\n')) %>% cat()
  
  ##EVALUATE CODE IN GLOBAL ENVIRONMENT
  ##make expression out of Code Statements
  DynamicNUTScodeExpr = parse(text = (DynamicNUTScodeStatements))
  
  NUTScodeExpr = parse(text = (NUTScodeStatements))

  HMCcodeExpr = parse(text = (HMCcodeStatements))
  
  #codeExpr = parse(text = codeStatements)
  
  ##eval expression
  if(DynamicNUTS == TRUE) {eval(DynamicNUTScodeExpr, envir = globalenv())}
  if(NUTS == TRUE) {eval(NUTScodeExpr, envir = globalenv())}
  if(HMC == TRUE) {eval(HMCcodeExpr, envir = globalenv())}
  
  ###return code
  return(invisible())
}